#labels Featured,tutorial,sip2peer
=sip2peer Tutorial=

sip2peer is an open-source SIP-based middleware for the implementation of any distributed and peer-to-peer application or overlay without constrains on peer/node nature (traditional PC or mobile nodes) and specific architecture.

Main characteristics are:

 * Multiplatform nature
 * Simple communication API with notification system
 * SIP-Based platform
 * NAT traversal management
 * Efficient, Scalable and Configurable structure

*Supported Platform*

At this moment sip2peer is available for Java SE and Android platforms, but we are working on the iOS release.

==Java/Android Tutorial==

This tutorial shows what are the main element of the library, how to create a simple peer that interacts with the others. We will analyze also the problem of NAT traversal and how to easily manage it with sip2peer. The code of this example and others more complex are available in the Sip2PeerExample.zip in the Download page.

As mentioned before the Java and the Android implementation of the library are based on the java SIP stack called mjSIP [http://www.mjsip.org http://www.mjsip.org] that allows to manage the exchange of SIP messages or multimedia streams. 

Creating our own peer class using sip2peer is extremely simple and it is only necessary to extend the Class called *Peer*. In our case we have:

{{{ 
public class SimplePeer extends Peer  
}}}

Class's constructor has to call the super method with  the path of peer configuration file (detailed information later in this tutorial) and the unique key of the peer in the network.

{{{
public SimplePeer(String pathConfig) {
		super(pathConfig, "a5ds465a465a45d4s64d6a");
}
}}}

Different constructors are available with different parameters and configuration:

{{{
1) public Peer(String pathConfig, String key);
2) public Peer(String pathConfig, String key, String peerName, int peerPort);
3) public Peer(String pathConfig, String key, String peerName, int peerPort, BasicParser parser);
4) public Peer(String pathConfig, String key, BasicParser parser);
}}} 

In particular in this tutorial we are focused on number 1 and 2 that allow to specify a configuration file with node parameters (details about configuration file is provided later in this tutorial) or additionally pass the peer port.  

Extending *Peer* Class the developer can to override different fundamental methods from the base class. The main important functions that should be override for the message exchange and for the communication are the following:

{{{

@Override
protected void onReceivedMsg(String peerMsg, Address sender, String contentType) {
	super.onReceivedMsg(peerMsg, sender, contentType);
        ...
}

@Override
protected void onReceivedJSONMsg(JSONObject jsonMsg, Address sender) {
	super.onReceivedJSONMsg(jsonMsg, sender);
        ...
}

@Override
protected void onDeliveryMsgFailure(String peerMsgSended, Address receiver,String contentType) {
	....	
}

@Override
protected void onDeliveryMsgSuccess(String peerMsgSended, Address receiver,String contentType) {
        ....      
}
}}}

These methods are called when the node receive a message (String or JSON based) and when a message is correctly delivered or if there are some errors.  

Four important methods  are inherited from the base class providing the appropriate functions to send a message to a destination node. These method are:

{{{

1) public void sendMessage(Address toAddress, Address fromAddress, String msg, String contentType)

2) public void sendMessage(Address toAddress, Address toContactAddress, Address fromAddress, String msg, String contentType)

3) public void send(Address toAddress, BasicMessage message);

4) public void send(Address toAddress, Address toContactAddress, BasicMessage message)
}}}

The difference between these methods is first of all that two of them (1,2) don't use our JSON based message approach but allows the developer to send a generic String to the destination whereas the others use our implementation of a base message as content. 
Another main difference among these functions is that method 3 and 4 use "toContactAddress" in addition to "toAddress" parameter. Contact address represents the real destination address of the target node while the first one is keept only as reference. This is useful in different scenarios where a peer behind a NAT advertises as contact address a specific ip:port different form the private one where it can receive incoming messages without firewall or NAT issues.

Extended Peer class also provides the following useful instances:
 * *PeerDescriptor*: a simple structure to keep information about node like:
   * name (loaded from configuration file)
   * key
   * address
   * contactAddress
 * *PeerListManager*: extends Hashtable defining a simple and ready to use structure to hold  peer descriptor of known nodes. 

Message definition and management in sip2peer by default is done using JSON format ([http://www.json.org/ http://www.json.org/]) but the design is open to allows new format as for example XML for the communication. 

In this tutorial we are focused to use the JSON feature both for message definition and exchange because it is more simple to define, parse, send and un-parse a generic message. For this reason we will use the appropriate methods associated with JSON and in particular:
 * protected void onReceivedJSONMsg(JSONObject jsonMsg, Address sender)
 * public void send(Address toAddress, BasicMessage message);
 * public void send(Address toAddress, Address toContactAddress, BasicMessage message)

The base class used to define a message that could be easily transformed in a JSON string is *BaseMessage* that defines a general structure made bye a:
 * long timestamp
 * String type
 * Payload payload

Payload in another base class of the library that defines a data structure of  key/value for the message (implements an Hashtable). The class permits different approach to create a payload, through constructors and methods. It is also possible to directly add and remove parameters from it. Detailed information are available in the JAVA Doc of the project.

If  for example we want to create a simple PING Message to send the node's PeerDescriptor to another active user we just need to extend BasicMessage class redefining the constructor according to our needs. The result class will be:

{{{
public class PingMessage extends BasicMessage {
	
	public static final String MSG_PEER_PING="peer_ping"; 
	
	
	public PingMessage(PeerDescriptor peerDesc) {
		
		super(MSG_PEER_PING, new Payload(peerDesc));
	
	}
}
}}}

The same approach can be used to create a message to send the peer list or for the JoinMessage.

{{{
public class PeerListMessage extends BasicMessage {

	public static final String MSG_PEER_LIST="peer_list"; 

	public PeerListMessage(PeerListManager peerList) {
		super(MSG_PEER_LIST, new Payload(peerList));
		
	}
}

public class JoinMessage extends BasicMessage{
	
	private int numPeerList;
	
	
	public static final String MSG_PEER_JOIN="peer_join"; 

	public JoinMessage(PeerDescriptor peerDesc) {
		
		super(MSG_PEER_JOIN, new Payload(peerDesc));
		setNumPeerList(0);
	}

	public int getNumPeerList() {
		return numPeerList;
	}

	public void setNumPeerList(int numPeerList) {
		this.numPeerList = numPeerList;
	}
}

}}}

As already described transmission of BasicMessage through send method 3 or 4 implies that message object is converted into a JSON Object and sent as a JSON format string. Citing the JSON library that we are using at the moment, the JSONObject constructor uses bean getters. It reflects on all of the public methods of the object. For each of the methods with no parameters and a name starting
with "get" or "is" followed by an uppercase letter, the method is invoked, and a key and the value returned from the getter method are put into the new JSONObject.
The key is formed by removing the "get" or "is" prefix. If the second remaining character is not upper case, then the first character is converted to lower case. For example, if an object has a method named "getName", and if the result of calling object.getName() is "Larry Fine", then the JSONObject will contain "name": "Larry Fine".   
For this reason as showed in the JoinMessage class is mandatory to implement get methods to expose those parameters that we want to include in the JSON object representing the message. This rule is valid also not only for the Message instance but also for each kind of Object added in the Payload.

It is also possible to explicitly add element to the payload as for this example of ACK Message:

{{{
public class AckMessage extends BasicMessage  {

	public static final String ACK_MSG="ack"; 
	
	public AckMessage(String status, String msg) {
		super();
		Payload payload = new Payload();
		payload.addParam("status", status);
		payload.addParam("msg", msg);	
		this.setType(ACK_MSG);
		this.setPayload(payload);
	}	
}
}}}  

In order to complete our simple peer class we just need add a function that allows to send a JoinMessage to a destination address and define the main to execute.

{{{
public void joinToPeer(String toAddress, String contactAddress){

		JoinMessage peerMsg = new JoinMessage(peerDescriptor);
		
		send(new Address(toAddress), new Address(contactAddress), peerMsg);
}

public static void main(String[] args) {

	if(args.length>0){
			SimplePeer peer = new SimplePeer("config/"+args[0]);
			peer.joinToPeer(args[1], args[2]);
        }
}
}}}


=== Node Configuration ===

Peer class provides by default an object to configure main parameters of the node. These values can be loaded from the file specified in the object constructor as first parameter or through code calling the appropriate methods.

Generally the main useful field for a node are:

 * peer_name=name of the peer advertised in its descriptor
 * format_message= by default is "json" but could be also "text"
 * sbc: ip:port of the available sbc
 * keepalive_time: keep alive time value
 
A configuration file has a simple structure of "key=value" with # to comment the line.
A useful example could be:

{{{
peer_name=kate
#format_message=json
sbc=160.78.28.112:6067
keepalive_time=5000
}}}

The same configuration can be obtained by code in the following way:

{{{
SimplePeer peer = new SimplePeer("config/"+args[0]);
peer.nodeConfig.sbc = "160.78.28.112:6067";
peer.nodeConfig.peer_name="kate";
peer.nodeConfig.keepalive_time=5000;
}}}

It is also possible for the developer to define his own class per additional configuration parameter. For the information it is possible to read the code of PeerConfig.java and its usage in FullPeer.java both available in the example zip archive. 

Additional SIP configuration for the node are available only by file and the some additional field that can be used are:

 * via_addr:  contains the desired ip address for the node or the "AUTO-CONFIGURATION" to automatically select the listening interface  
 * host_port: node's port. 

A configuration file with SIP parameters is:

{{{
via_addr=AUTO-CONFIGURATION 
host_port=5075
peer_name=kate
#format_message=json
sbc=160.78.28.112:6067
keepalive_time=5000
debug_level=1
}}}

For detailed information of other SIP parameter we refer to mjSIP details on the official website on in the JAVA Doc.

=== NAT Management ===

Network Address Translation ([http://en.wikipedia.org/wiki/Network_address_translation NAT])  is the process of modifying network address information in datagram (IP) packet headers while in transit across a traffic routing device for the purpose of remapping one IP address space into another. Is a technique that hides an entire IP address space, usually consisting of private network IP addresses (RFC 1918), behind a single IP address in another, often public address space.

Nowadays NAT is a very common element in computer networking and in particular for peer-to-peer application could represent a very important issue for the communication.

In VoIP (Voice over Internet Protocol) network a device that is regularly deployed and used also to solve NAT traversal problem is called Session Border Controller ([http://en.wikipedia.org/wiki/Session_border_controller SBC]). 
Being sip2peer based on SIP protocol, SBC represent a natural and easily way to solve that  