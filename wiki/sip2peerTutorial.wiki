#labels Featured,tutorial,sip2peer
=sip2peer Tutorial=

sip2peer is an open-source SIP-based middleware for the implementation of any distributed and peer-to-peer application or overlay without constrains on peer/node nature (traditional PC or mobile nodes) and specific architecture.

Main characteristics are:

 * Multiplatform nature
 * Simple communication API with notification system
 * SIP-Based platform
 * NAT traversal management
 * Efficient, Scalable and Configurable structure

*Supported Platform*

At this moment sip2peer is available for Java SE and Android platforms, but we are working on the iOS release.

==Java/Android Tutorial==

This tutorial shows what are the main element of the library, how to create a simple peer that interacts with the others. We will analyze also the problem of NAT traversal and how to easily manage it with sip2peer. The code of this example and others more complex are available in the Sip2PeerExample.zip in the Download page.

As mentioned before the Java and the Android implementation of the library are based on the java SIP stack called mjSIP [http://www.mjsip.org http://www.mjsip.org] that allows to manage the exchange of SIP messages or multimedia streams. 

Creating our own peer class using sip2peer is extremely simple and it is only necessary to extend the Class called *Peer*. In our case we have:

{{{ 
public class SimplePeer extends Peer  
}}}

Class's constructor has to call the super method with  the path of peer configuration file (detailed information later in this tutorial) and the unique key of the peer in the network.

{{{
public SimplePeer(String pathConfig) {
		super(pathConfig, "a5ds465a465a45d4s64d6a");
}
}}}

Extending *Peer* Class the developer can to override different fundamental methods from the base class. The main important functions that should be override for the message exchange and for the communication are the following:

{{{

@Override
protected void onReceivedMsg(String peerMsg, Address sender, String contentType) {
	super.onReceivedMsg(peerMsg, sender, contentType);
        ...
}

@Override
protected void onReceivedJSONMsg(JSONObject jsonMsg, Address sender) {
	super.onReceivedJSONMsg(jsonMsg, sender);
        ...
}

@Override
protected void onDeliveryMsgFailure(String peerMsgSended, Address receiver,String contentType) {
	....	
}

@Override
protected void onDeliveryMsgSuccess(String peerMsgSended, Address receiver,String contentType) {
        ....      
}
}}}

These methods are called when the node receive a message (String or JSON based) and when a message is correctly delivered or if there are some errors.  

Four important methods  are inherited from the base class providing the appropriate functions to send a message to a destination node. These method are:

{{{

1) public void sendMessage(Address toAddress, Address fromAddress, String msg, String contentType)

2) public void sendMessage(Address toAddress, Address toContactAddress, Address fromAddress, String msg, String contentType)

3) public void send(Address toAddress, BasicMessage message);

4) public void send(Address toAddress, Address toContactAddress, BasicMessage message)
}}}

The difference between these methods is first of all that two of them (1,2) don't use our JSON based message approach but allows the developer to send a generic String to the destination whereas the others use our implementation of a base message as content. 
Another main difference among these functions is that method 3 and 4 use "toContactAddress" in addition to "toAddress" parameter. Contact address represents the real destination address of the target node while the first one is keept only as reference. This is useful in different scenarios where a peer behind a NAT advertises as contact address a specific ip:port different form the private one where it can receive incoming messages without firewall or NAT issues.

Extended Peer class also provides the following useful instances:
 * *PeerDescriptor*: a simple structure to keep information about node like:
   * name (loaded from configuration file)
   * key
   * address
   * contactAddress
 * *PeerListManager*: extends Hashtable defining a simple and ready to use structure to hold  peer descriptor of known nodes. 

Message definition and management in sip2peer by default is done using JSON format ([http://www.json.org/ http://www.json.org/]) but the design is open to allows new format as for example XML for the communication. 

In this tutorial we are focused to use the JSON feature both for message definition and exchange because it is more simple to define, parse, send and un-parse a generic message. For this reason we will use the appropriate methods associated with JSON and in particular:
 * protected void onReceivedJSONMsg(JSONObject jsonMsg, Address sender)
 * public void send(Address toAddress, BasicMessage message);
 * public void send(Address toAddress, Address toContactAddress, BasicMessage message)

The base class used to define a message that could be easily transformed in a JSON string is *BaseMessage* that defines a general structure made bye a:
 * long timestamp
 * String type
 * Payload payload

Payload in another base class of the library that defines a data structure of  key/value for the message (implements an Hashtable). The class permits different approach to create a payload, through constructors and methods. It is also possible to directly add and remove parameters from it. Detailed information are available in the JAVA Doc of the project.

If  for example we want to create a simple PING Message to send the node's PeerDescriptor to another active user we just need to extend BasicMessage class redefining the constructor according to our needs. The result class will be:

{{{
public class PingMessage extends BasicMessage {
	
	public static final String MSG_PEER_PING="peer_ping"; 
	
	
	public PingMessage(PeerDescriptor peerDesc) {
		
		super(MSG_PEER_PING, new Payload(peerDesc));
	
	}
}
}}}

The same approach can be used to create a message to send the peer list.

{{{
public class PeerListMessage extends BasicMessage {

	public static final String MSG_PEER_LIST="peer_list"; 

	public PeerListMessage(PeerListManager peerList) {
		super(MSG_PEER_LIST, new Payload(peerList));
		
	}
}
}}}
   